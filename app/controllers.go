// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "ATQ - Director": Application Controllers
//
// Command:
// $ goagen
// --design=github.com/mtenrero/ATQ-Director/http/design
// --out=$(GOPATH)\src\github.com\mtenrero\ATQ-Director
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
)

// initService sets up the service encoders, decoders and mux.
func initService(service *goa.Service) {
	// Setup encoders and decoders
	service.Encoder.Register(goa.NewJSONEncoder, "application/json")
	service.Decoder.Register(goa.NewJSONDecoder, "application/json")

	// Setup default encoder and decoder
	service.Encoder.Register(goa.NewJSONEncoder, "*/*")
	service.Decoder.Register(goa.NewJSONDecoder, "*/*")
}

// DatabindController is the controller interface for the Databind actions.
type DatabindController interface {
	goa.Muxer
	List(*ListDatabindContext) error
	Upload(*UploadDatabindContext) error
}

// MountDatabindController "mounts" a Databind resource controller on the given service.
func MountDatabindController(service *goa.Service, ctrl DatabindController) {
	initService(service)
	var h goa.Handler

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewListDatabindContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.List(rctx)
	}
	service.Mux.Handle("GET", "/api/databind/list", ctrl.MuxHandler("list", h, nil))
	service.LogInfo("mount", "ctrl", "Databind", "action", "List", "route", "GET /api/databind/list")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUploadDatabindContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UploadPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Upload(rctx)
	}
	service.Mux.Handle("POST", "/api/databind/upload", ctrl.MuxHandler("upload", h, unmarshalUploadDatabindPayload))
	service.LogInfo("mount", "ctrl", "Databind", "action", "Upload", "route", "POST /api/databind/upload")
}

// unmarshalUploadDatabindPayload unmarshals the request body into the context request data Payload field.
func unmarshalUploadDatabindPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &uploadPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// MonitoringController is the controller interface for the Monitoring actions.
type MonitoringController interface {
	goa.Muxer
	Ping(*PingMonitoringContext) error
}

// MountMonitoringController "mounts" a Monitoring resource controller on the given service.
func MountMonitoringController(service *goa.Service, ctrl MonitoringController) {
	initService(service)
	var h goa.Handler

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewPingMonitoringContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Ping(rctx)
	}
	service.Mux.Handle("GET", "/api/monitoring/ping", ctrl.MuxHandler("ping", h, nil))
	service.LogInfo("mount", "ctrl", "Monitoring", "action", "Ping", "route", "GET /api/monitoring/ping")
}

// SwarmController is the controller interface for the Swarm actions.
type SwarmController interface {
	goa.Muxer
	Status(*StatusSwarmContext) error
}

// MountSwarmController "mounts" a Swarm resource controller on the given service.
func MountSwarmController(service *goa.Service, ctrl SwarmController) {
	initService(service)
	var h goa.Handler

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewStatusSwarmContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Status(rctx)
	}
	service.Mux.Handle("GET", "/api/swarm/", ctrl.MuxHandler("status", h, nil))
	service.LogInfo("mount", "ctrl", "Swarm", "action", "Status", "route", "GET /api/swarm/")
}

// TaskController is the controller interface for the Task actions.
type TaskController interface {
	goa.Muxer
	Create(*CreateTaskContext) error
	Delete(*DeleteTaskContext) error
	Inspect(*InspectTaskContext) error
}

// MountTaskController "mounts" a Task resource controller on the given service.
func MountTaskController(service *goa.Service, ctrl TaskController) {
	initService(service)
	var h goa.Handler

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCreateTaskContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*TaskPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Create(rctx)
	}
	service.Mux.Handle("PUT", "/api/task/", ctrl.MuxHandler("create", h, unmarshalCreateTaskPayload))
	service.LogInfo("mount", "ctrl", "Task", "action", "Create", "route", "PUT /api/task/")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeleteTaskContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Delete(rctx)
	}
	service.Mux.Handle("DELETE", "/api/task/:id", ctrl.MuxHandler("delete", h, nil))
	service.LogInfo("mount", "ctrl", "Task", "action", "Delete", "route", "DELETE /api/task/:id")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewInspectTaskContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Inspect(rctx)
	}
	service.Mux.Handle("GET", "/api/task/:id", ctrl.MuxHandler("inspect", h, nil))
	service.LogInfo("mount", "ctrl", "Task", "action", "Inspect", "route", "GET /api/task/:id")
}

// unmarshalCreateTaskPayload unmarshals the request body into the context request data Payload field.
func unmarshalCreateTaskPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &taskPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}
